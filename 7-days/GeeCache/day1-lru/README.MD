### 1、目标：实现LRU

* * *


#### 1.1、何为Cache？
cache，即缓存。在数据量少的时候，我们可以通过直接访问数据库的方式来读取数据。但随着数据量增加和访问量的提高，频繁的访问数据库会导致效率下降，并且数据库每秒能接受的请求次数也是有限的。cache的提出就是为了解决这个问题，它将部分数据存放在缓存中，比如直接放在内存里，这样访问到这部分数据的时候便直接从内存读取而不需要请求数据库，从而提高了访问效率。

* * *
#### 1.2、何为cache策略？
有了缓存之后，新的问题随之而来——缓存大小也是有限的，如果缓存满了怎么办？此时就需要一定的策略来决定哪些数据能够继续留在缓存里，而哪些应该被淘汰。实现一个分布式缓存的第一步就是要确定淘汰策略。淘汰策略有什么？回顾考研操作系统，常见替换策略有FIFO、LFU、LRU。
##### 1.2.1、FIFO
FIFO实现起来很简单，就是淘汰缓存中最早进来的记录。实现这一策略我们可以通过设计一个队列，新纪录添加到队尾，旧记录在队头等待淘汰。

FIFO的适用性场景主要是对局数据时效性要求低的时候，优先保证最新数据可用。
##### 1.2.2、LFU
最少使用策略，即每次都清除最少使用的那个，主要比较命中率。在保证高频数据有消息的场景下，可用选择这个策略。
##### 1.2.3、LRU
最近最少使用策略，即清除最后一次被使用的。该策略主要优先保证热点数据的有效性。即热点条件下更适用

#### 1.3、在哪存放cache？
无非是内存和硬盘，但技术上可以分为内存、硬盘文件、数据库。

#### 1.4、缓存分类
##### 1.4.1、本地缓存
即缓存设置在应用内，请求速度非常迅速，无需网络开销。单应用不需要集群支持或者集群情况下各节点无需互相通知的场景下使用本地缓存比较合适，但多个应用之间无法直接共享。
##### 1.4.2、分布式缓存
与应用分离，多个应用可以共享。

#### 1.5、推荐阅读
https://tech.meituan.com/2017/03/17/cache-about.html

* * *


### 2、代码解析

#### 2.1、type Cache struct{  }
代码如下：
```
type Cache struct {
    maxBytes  int64                         //Cache的最大容量
    nBytes    int64                         //当前使用的空间
    ll        *list.List                    //cache队列，Go语言标准库可以实现
    cache     map[string]*list.Element      //键是字符串，值是双向链表中对应的节点指针
    OnEvicted func(key string, value Value) //某条记录被删除时的回调函数
}
```
首先定义了结构体Cache，Cache中总共有maxBytes\nBytes\ll\cache\OnEvicted 五个值。其中值得注意的是OnEvicted是一个函数类型，其中涉及到了类型“Value”还未定义，这个会在后面进行解释。

缓存区有两个主要指标，一个是缓存区的总容量，令一个是当前用了多少缓存。LRU是最近最少使用的淘汰。不同于LFU（最少使用淘汰），LFU是为每个cache元素设置计数器，每次需要淘汰时选择计数器值最小的那个淘汰。LRU的原理并非统计次数，而是命中一次就往后移，每次只淘汰队伍第一个。
因此我们设置最大内存maxBytes，当前使用内存nBytes，可以简单理解为总位置数和已经占用的位置数。接着设置双向链表ll，用于实现淘汰。
##### 2.1.1、为什么要设置map？
如果仅仅是有一个双向链表，我们可以想象一个场景，当由新的数据访问，我们首先要确认这个数据是否在缓存队列中，如果仅仅依靠链表，则需要从头开始遍历链表，此时如果能通过数据的值直接定位到链表的位置是不是更快呢？因此我们为了加速访问还要引入字典map确保查找高效。

注意，map的作用不是统计，而仅仅是为了在O(1)的复杂度下定位到队列的位置。

Go中的map声明方式为`map[ key] value`，key为键值，在这里我们将存储缓存的具体值（比如文中是字符串），value值则为链表元素。这样当我们拿到一个值之后（实际中可以是图像、数据、音频等等），我们可以直接用map的查找确定这个在不在队列中，然后再进行后续的操作。

#### 2.2、type Value interface{  }
相关链接：https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/

```
type Value interface { //interface用来定义对象的一组行为
    Len() int //定义Value接口，用具返回值所用的内存大小
}
```
接口（interface）的引入最直接的就是上下层的模块不再需要依赖下层的具体模块，只需要用接口即可实现。

首先Value即为接口的方法签名。即这个接口从此就叫做Value，它不是成员变量之类的东西。

这个接口它只做一件事情，就是定义了一个函数Len( )，并且Len( )将会返回int。初次接触到我们可能会好奇它如何使用它。在Go官方文档中有Len()函数用来返回队列长度。


#### 2.3、type entry struct{ }
```
type entry struct {
    key   string
    value Value
}
```
定义结构体entry中有两个数据，一个是string型的key，和map的key是对应的。另一个是Value型的value，这样方便使用接口进行长度计算。

有一点好奇的是，为什么有了map的键值对应还要在链表中保留key值呢？map中的结构为[key: value]，key可以理解为map的编号，value理解为实际cache队列中的值。如果我们要淘汰头结点的时候，同时需要把map中的元素删除。假设链表没有设置key，那么则无法在map中找到对应的元素。所以这其实是一个双向对应的关系。